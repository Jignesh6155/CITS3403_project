To run unit tests:

## Run from parent directory of project

# Unit tests
python3 -m unittest discover tests

# System (Selenium) tests
python3 -m unittest tests/test_system.py


What was added:
    tests/test_utils.py
        Unit tests for app.utils.fuzzy_search and app.utils.resume_processor.
        Covers fuzzy matching, job matching, text extraction, and mocks OpenAI API calls.
        Comment: If you want to test with real files, add sample PDFs/DOCX and update the tests.
    tests/test_routes.py
        Unit tests for major Flask routes using Flask's test client.
        Covers home, signup, signin, dashboard (auth required), logout, and job search.
        Uses TestingConfig for isolation.
        Comment: To test more endpoints, add methods and set session['name'] for authenticated routes.
    tests/test_models.py
        Unit tests for User and JobApplication models.
        Tests creation, relationships, and basic CRUD.
        Comment: Extend to test more models and relationships as needed.
    tests/__init__.py
        Empty file to make tests a package (required for some runners/imports).
    tests/base.py
        Base class for Flask tests with mock DB setup/teardown using TestingConfig.
        Inherit from this class for consistent DB isolation in all your tests.

---

Mock Database Setup for Testing:
- All tests use an in-memory SQLite database for isolation and speed.
- This is configured via TestingConfig in app/config.py.
- The base class in tests/base.py handles setup/teardown for you.
- To add more tests, simply inherit from FlaskTestBase in your test file:

    from tests.base import FlaskTestBase
    class MyTest(FlaskTestBase):
        def test_something(self):
            ...

- If you want to use a different test database, edit TestingConfig in app/config.py.
- All data is wiped between tests, so each test runs in a clean environment.